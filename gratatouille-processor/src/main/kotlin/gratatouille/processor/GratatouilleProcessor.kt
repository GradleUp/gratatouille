package gratatouille.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.ksp.writeTo
import gratatouille.processor.codegen.entryPoint
import gratatouille.processor.codegen.plugin
import gratatouille.processor.codegen.taskFile
import gratatouille.processor.ir.Classpath
import gratatouille.processor.ir.IrPlugin
import gratatouille.processor.ir.IrTaskProperty
import gratatouille.processor.ir.toGTask
import gratatouille.processor.ir.toIrPlugin
import java.util.Properties

class GratatouilleProcessor(
  private val codeGenerator: CodeGenerator,
  private val logger: KSPLogger,
  private val isolationOptions: IsolationOptions?,
  private val enableKotlinxSerialization: Boolean,
) : SymbolProcessor {
  override fun process(resolver: Resolver): List<KSAnnotated> {
    processTasks(resolver.getSymbolsWithAnnotation("$gratatouilleTasksPackageName.GTask"))
    processPlugins(resolver.getSymbolsWithAnnotation("$gratatouilleWiringPackageName.GPlugin"))
    processExtensions(resolver.getSymbolsWithAnnotation("$gratatouilleWiringPackageName.GExtension"))

    return emptyList()
  }

  private fun writePlugin(irPlugin: IrPlugin?, source: KSDeclaration) {
    irPlugin?.apply {
      val dependencies = source.asIsolatingDependencies()
      plugin().writeToKotlinDirectory(dependencies)

      // Write the descriptor
      codeGenerator.createNewFile(
        dependencies,
        "",
        "META-INF/gradle-plugins/${id}.properties",
        ""
      ).writer().use {
        /**
         * Write a descriptor looking like this:
         *
         * ```
         * #Gradle plugin descriptor (auto-generated by Gratatouille)
         * implementation-class=testplugin.TestPlugin
         * ```
         *
         * Note that we are not using [java.util.Properties] because they
         * write a timestamp that makes builds non-reproducible.
         *
         * TODO: do we need escaping of the plugin class name? I don't expect any exotic character there but maybe?
         */
        it.append("#Gradle plugin descriptor (auto-generated by Gratatouille)\n")
        it.append("implementation-class=")
        it.append(packageName)
        if (packageName.isNotEmpty()) {
          it.append('.')
        }
        it.append(simpleName)
        it.append("\n")
      }
    }
  }

  private fun processPlugins(symbols: Sequence<KSAnnotated>) {
    symbols.forEach {
      when (it) {
        is KSFunctionDeclaration -> {
          writePlugin(it.toIrPlugin(logger), it)
        }

        else -> {
          logger.error("@GPlugin is only valid on functions", it)
          null
        }
      }
    }
  }

  private fun processExtensions(symbols: Sequence<KSAnnotated>) {
    symbols.forEach {
      when (it) {
        is KSClassDeclaration -> {
          writePlugin(it.toIrPlugin(logger), it)
        }

        else -> {
          logger.error("@GExtension is only valid on classes", it)
          null
        }
      }
    }
  }

  private fun FileSpec.writeToKotlinDirectory(dependencies: Dependencies) = writeTo(codeGenerator, dependencies)
  private fun FileSpec.writeToKotlinOrResourcesDirectory(dependencies: Dependencies) {
    val fileSpec = this
    val file = if (isolationOptions != null) {
      codeGenerator.createNewFile(
        dependencies,
        "",
        "META-INF/gratatouille/${fileSpec.packageName.replace(".", "/")}/${fileSpec.name}.kt",
        ""
      )
    } else {
      codeGenerator.createNewFile(
        dependencies,
        fileSpec.packageName,
        fileSpec.name,
      )
    }
    file.writer().use {
      fileSpec.writeTo(it)
    }
  }

  private fun processTasks(symbols: Sequence<KSAnnotated>) {
    symbols.forEach { it ->
      when (it) {
        is KSFunctionDeclaration -> {
          val dependencies = it.asIsolatingDependencies()
          it.toGTask(logger, isolationOptions, enableKotlinxSerialization).apply {
            entryPoint().writeToKotlinDirectory(dependencies)
            taskFile().writeToKotlinOrResourcesDirectory(dependencies)
          }
        }

        else -> error("@GTask is only valid on functions")
      }
    }
  }

  private fun KSDeclaration.asIsolatingDependencies(): Dependencies {
    check(containingFile != null) {
      logger.error("Gratatouille: a symbol is missing a containing file", this)
      return Dependencies.ALL_FILES
    }
    return Dependencies(false, containingFile!!)
  }
}

class GratatouilleProcessorProvider : SymbolProcessorProvider {
  override fun create(
    environment: SymbolProcessorEnvironment
  ): SymbolProcessor {
    val coordinates = environment.options.get("implementationCoordinates")
    val isolationOptions = if (coordinates != null) {
      IsolationOptions(coordinates, environment.options.get("configurationName")!!)
    } else {
      null
    }
    return GratatouilleProcessor(
      environment.codeGenerator,
      environment.logger,
      isolationOptions,
      environment.options.get("enableKotlinxSerialization").toBoolean()
    )
  }
}

internal val classpathParameter = IrTaskProperty(Classpath, classpath, false, false, false)

class IsolationOptions(
  val coordinates: String,
  val configurationName: String
)