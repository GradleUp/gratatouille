package gratatouille.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.ksp.writeTo
import gratatouille.processor.codegen.entryPoint
import gratatouille.processor.codegen.plugin
import gratatouille.processor.codegen.taskFile
import gratatouille.processor.ir.Classpath
import gratatouille.processor.ir.IrPlugin
import gratatouille.processor.ir.IrTaskProperty
import gratatouille.processor.ir.toGTask
import gratatouille.processor.ir.toIrPlugin
import java.util.Properties

class GratatouilleProcessor(
  private val codeGenerator: CodeGenerator,
  private val logger: KSPLogger,
  private val implementationCoordinates: String?,
  private val enableKotlinxSerialization: Boolean,
) : SymbolProcessor {
  override fun process(resolver: Resolver): List<KSAnnotated> {
    processTasks(resolver.getSymbolsWithAnnotation("$gratatouilleTasksPackageName.GTask"))
    processPlugins(resolver.getSymbolsWithAnnotation("$gratatouilleWiringPackageName.GPlugin"))
    processExtensions(resolver.getSymbolsWithAnnotation("$gratatouilleWiringPackageName.GExtension"))

    return emptyList()
  }

  private fun writePlugin(irPlugin: IrPlugin?, source: KSDeclaration) {
    irPlugin?.apply {
      val dependencies = source.asIsolatingDependencies()
      plugin().writeToKotlinDirectory(dependencies)

      // Write the descriptor
      codeGenerator.createNewFile(
        dependencies,
        "",
        "META-INF/gradle-plugins/${id}.properties",
        ""
      ).writer().use {
        Properties().apply {
          this.put("implementation-class", "$packageName.$simpleName")
        }.store(it, "Gradle plugin descriptor (auto-generated by Gratatouille)")
      }
    }
  }

  private fun processPlugins(symbols: Sequence<KSAnnotated>) {
    symbols.forEach {
      when (it) {
        is KSFunctionDeclaration -> {
          writePlugin(it.toIrPlugin(logger), it)
        }

        else -> {
          logger.error("@GPlugin is only valid on functions", it)
          null
        }
      }
    }
  }

  private fun processExtensions(symbols: Sequence<KSAnnotated>) {
    symbols.forEach {
      when (it) {
        is KSClassDeclaration -> {
          writePlugin(it.toIrPlugin(logger), it)
        }

        else -> {
          logger.error("@GExtension is only valid on classes", it)
          null
        }
      }
    }
  }

  private fun FileSpec.writeToKotlinDirectory(dependencies: Dependencies) = writeTo(codeGenerator, dependencies)
  private fun FileSpec.writeToKotlinOrResourcesDirectory(dependencies: Dependencies) {
    val fileSpec = this
    val file = if (implementationCoordinates != null) {
      codeGenerator.createNewFile(
        dependencies,
        "",
        "META-INF/gratatouille/${fileSpec.packageName.replace(".", "/")}/${fileSpec.name}.kt",
        ""
      )
    } else {
      codeGenerator.createNewFile(
        dependencies,
        fileSpec.packageName,
        fileSpec.name,
      )
    }
    file.writer().use {
      fileSpec.writeTo(it)
    }
  }

  private fun processTasks(symbols: Sequence<KSAnnotated>) {
    symbols.forEach { it ->
      when (it) {
        is KSFunctionDeclaration -> {
          val dependencies = it.asIsolatingDependencies()
          it.toGTask(implementationCoordinates, enableKotlinxSerialization).apply {
            entryPoint().writeToKotlinDirectory(dependencies)
            taskFile().writeToKotlinOrResourcesDirectory(dependencies)
          }
        }

        else -> error("@GTask is only valid on functions")
      }
    }
  }

  private fun KSDeclaration.asIsolatingDependencies(): Dependencies {
    check(containingFile != null) {
      logger.error("Gratatouille: a symbol is missing a containing file", this)
      return Dependencies.ALL_FILES
    }
    return Dependencies(false, containingFile!!)
  }
}

class GratatouilleProcessorProvider : SymbolProcessorProvider {
  override fun create(
    environment: SymbolProcessorEnvironment
  ): SymbolProcessor {
    return GratatouilleProcessor(
      environment.codeGenerator,
      environment.logger,
      environment.options.get("implementationCoordinates"),
      environment.options.get("enableKotlinxSerialization").toBoolean()
    )
  }
}

internal val classpathParameter = IrTaskProperty(Classpath, classpath, false, false, false)