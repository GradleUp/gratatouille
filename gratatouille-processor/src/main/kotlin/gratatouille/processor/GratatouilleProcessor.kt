package gratatouille.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.ksp.writeTo
import gratatouille.processor.codegen.entryPoint
import gratatouille.processor.codegen.plugin
import gratatouille.processor.codegen.taskFile
import gratatouille.processor.ir.InputFiles
import gratatouille.processor.ir.Property
import gratatouille.processor.ir.toGTask
import gratatouille.processor.ir.toIrPlugin
import java.util.Properties

class GratatouilleProcessor(
  private val codeGenerator: CodeGenerator,
  private val logger: KSPLogger,
  private val implementationCoordinates: String?,
) : SymbolProcessor {
  override fun process(resolver: Resolver): List<KSAnnotated> {
    processPlugins(resolver.getSymbolsWithAnnotation("gratatouille.GPlugin"))
    processTasks(resolver.getSymbolsWithAnnotation("gratatouille.GTask"))

    return emptyList()
  }

  private fun processPlugins(symbols: Sequence<KSAnnotated>) {
    symbols.forEach {
      when (it) {
        is KSDeclaration -> {
          val dependencies = it.asIsolatingDependencies()
          val irPlugin = when(it) {
            is KSClassDeclaration -> {
              it.toIrPlugin(logger)
            }
            is KSFunctionDeclaration -> {
              it.toIrPlugin(logger)
            }
            else -> {
              logger.error("@GPlugin is only valid on functions and classes", it)
              null
            }
          }
          irPlugin?.apply {
            plugin().writeToPluginDirectory(dependencies)

            // Write the descriptor
            codeGenerator.createNewFile(
              dependencies,
              "",
              "META-INF/gradle-plugins/${id}.properties",
              ""
            ).writer().use {
              Properties().apply {
                this.put("implementation-class", "$packageName.${simpleName.capitalizeFirstLetter()}Plugin")
              }.store(it, "Gradle plugin descriptor (auto-generated by Gratatouille)")
            }
          }
        }
      }
    }
  }

  private fun FileSpec.writeToKotlinDirectory(dependencies: Dependencies) = writeTo(codeGenerator, dependencies)
  private fun FileSpec.writeToPluginDirectory(dependencies: Dependencies) {
    val fileSpec = this
    val file = if (implementationCoordinates != null) {
      codeGenerator.createNewFile(
        dependencies,
        "",
        "META-INF/gratatouille/${fileSpec.packageName.replace(".", "/")}/${fileSpec.name}.kt",
        ""
      )
    } else {
      codeGenerator.createNewFile(
        dependencies,
        fileSpec.packageName,
        fileSpec.name,
      )
    }
    file.writer().use {
      fileSpec.writeTo(it)
    }
  }

  private fun processTasks(symbols: Sequence<KSAnnotated>) {
    symbols.forEach { it ->
      when (it) {
        is KSFunctionDeclaration -> {
          val dependencies = it.asIsolatingDependencies()
          it.toGTask(implementationCoordinates).apply {
            entryPoint().writeToKotlinDirectory(dependencies)
            taskFile().writeToPluginDirectory(dependencies)
          }
        }

        else -> error("@GTask is only valid on functions")
      }
    }
  }

  private fun KSDeclaration.asIsolatingDependencies(): Dependencies {
    check(containingFile != null) {
      logger.error("Gratatouille: a symbol is missing a containing file", this)
      return Dependencies.ALL_FILES
    }
    return Dependencies(false, containingFile!!)
  }
}

class GratatouilleProcessorProvider : SymbolProcessorProvider {
  override fun create(
    environment: SymbolProcessorEnvironment
  ): SymbolProcessor {
    return GratatouilleProcessor(
      environment.codeGenerator,
      environment.logger,
      environment.options.get("implementationCoordinates")
    )
  }
}

internal val classpathProperty = Property(InputFiles, classpath, false, false, false)